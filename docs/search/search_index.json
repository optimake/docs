{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to OPTIMake!","text":""},{"location":"#optimake-build-your-ultrafast-solver","title":"OPTIMake: Build Your Ultrafast Solver","text":"<p>\u4f17\u6240\u5468\u77e5\uff0c\u57fa\u4e8e\u5b9e\u65f6\u5728\u7ebf\u4f18\u5316\u7684\u63a7\u5236\u4e0e\u51b3\u7b56\uff0c\u5df2\u7ecf\u6210\u4e3a\u667a\u80fd\u673a\u5668\u5b9e\u73b0\u590d\u6742\u52a8\u6001\u884c\u4e3a\u7684\u57fa\u672c\u8ba1\u7b97\u9014\u5f84\u3002 \u5c24\u5176\u4ee5\u7528\u4e8e\u975e\u7ebf\u6027\u6700\u4f18\u63a7\u5236\u7684\u5b9e\u65f6\u5d4c\u5165\u5f0f\u6c42\u89e3\u5668\u6280\u672f\u663e\u793a\u51fa\u6839\u672c\u7684\u91cd\u8981\u6027\u3002</p> <p>OPTIMake\u662f\u4e00\u5957\u4e13\u6ce8\u4e8e\u5f00\u53d1\u673a\u5668\u4eba\u98de\u884c\u5668\u4ee5\u53ca\u65e0\u4eba\u9a7e\u9a76\u7b49\u9886\u57df\u4e2d\u7684\u4e0b\u4e00\u4ee3\u6a21\u578b\u9884\u6d4b\u63a7\u5236(MPC)\u7cfb\u7edf\u57fa\u7840\u6027\u5de5\u5177\u3002 \u6211\u4eec\u7684\u4e13\u4e1a\u77e5\u8bc6\u6db5\u76d6\u5148\u8fdb\u7684\u591a\u53d8\u91cf\u63a7\u5236\u8bbe\u8ba1\u3001\u6700\u5148\u8fdb\u7684\u4f18\u5316\u7b97\u6cd5\u4ee5\u53ca\u9ad8\u6548\u7a33\u5065\u7684\u8f6f\u4ef6\u5b9e\u73b0\u3002</p> <p>For full documentation visit optimake.net.</p>"},{"location":"about/","title":"About","text":"<p>OPTIMake \u662f\u4e00\u4e2a\u6709\u6548\u89e3\u51b3\u6700\u4f18\u63a7\u5236\u548c\u4f30\u8ba1\u95ee\u9898\u7684\u8f6f\u4ef6\uff0c\u5c24\u5176\u9002\u7528\u4e8e\u673a\u5668\u4eba\u548c\u81ea\u52a8\u9a7e\u9a76\u8fd0\u52a8\u89c4\u5212\u3001\u98de\u884c\u5668\u8f68\u8ff9\u89c4\u5212\u7b49\u9700\u8981\u5728\u7ebf\u51b3\u7b56\u7684\u4efb\u52a1\u3002 \u5b83\u662fOPTIMake\u56e2\u961f\u5728\u5438\u6536\u56fd\u5916\u5148\u8fdb\u4f18\u5316\u6c42\u89e3\u7b97\u6cd5\u3001\u786c\u4ef6\u52a0\u901f\u4ee5\u53ca\u6a21\u578b\u9884\u6d4b\u63a7\u5236\u7b49\u6280\u672f\u53d1\u5c55\u6210\u679c\u4e4b\u4e0a\uff0c\u7ed3\u5408\u6c42\u89e3\u5668\u5f00\u53d1\u548c\u5b9e\u8df5\u4e2d\u79ef\u7d2f\u7684\u7ecf\u9a8c\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u7684\u4e00\u7ec4\u5de5\u5177\u94fe\u3002 \u9664\u5176\u4ed6\u5916\uff0c\u5b83\u5b9e\u73b0\u4e86\uff1a\u5e38\u5fae\u5206\u65b9\u7a0b\uff08ODE\uff09\u548c\u5fae\u5206\u4ee3\u6570\u65b9\u7a0b\uff08DAE\uff09\u7684\u96c6\u6210\u6a21\u5757\uff0c\u4e0eqpOASES\u3001OSQP\u7b49\u6700\u5148\u8fdb\u7684QP\u4ee5\u53caipopt\u3001SNOPT\u7b49\u975e\u7ebf\u6c42\u89e3\u5668\u7684\u63a5\u53e3\uff0c\u57fa\u4e8e\u5b9e\u65f6\u8fed\u4ee3\u6846\u67b6\u7684condensing routines\u548c\u975e\u7ebf\u6027/\u975e\u51f8\u89c4\u5212\u6c42\u89e3\u5668\u3002</p> <p>OPTIMake\u7684\u540e\u7aef\u7ed3\u5408MPC\u5728\u8ba1\u7b97\u4e0a\u7684\u7279\u70b9\uff0c\u5b9e\u73b0\u4e86\u4e00\u5957\u9ad8\u6027\u80fd\u4e14\u8f7b\u91cf\u5316\u7684\u7ebf\u6027\u4ee3\u6570\u5e93\uff0c\u4ee5\u63d0\u9ad8\u5d4c\u5165\u5f0f\u4f18\u5316\u5e94\u7528\u7a0b\u5e8f\u4e2d\u5178\u578b\u7684\u4e2d\u5c0f\u578b\u77e9\u9635\u7684\u8ba1\u7b97\u6548\u7387\u3002 Python\u548cMATLAB\u3001Octave\u63a5\u53e3\u53ef\u7528\u4e8e\u65b9\u4fbf\u5730\u63cf\u8ff0\u6700\u4f18\u63a7\u5236\u95ee\u9898\uff0c\u5e76\u751f\u6210\u53ef\u8f7b\u677e\u90e8\u7f72\u5728\u5d4c\u5165\u5f0f\u5e73\u53f0\u4e0a\u7684C/C++\u4ee3\u7801\u3002</p> <p>OPTIMization, Make it possible!</p>"},{"location":"about/#citing-optimake","title":"Citing OPTIMake","text":"<p>Coming soon.</p>"},{"location":"about/#contacting-us","title":"Contacting Us","text":"<p>Please do not hesitate to contact us if you have any questions. We would be very happy to hear your advices, experiences, stories, and contributions.</p> <p>You can contact us by:</p> <ul> <li>posting an issue on OPTIMake: Issue.</li> <li>E-mail: user [at] optimake.net</li> <li>joining our QQ Group: xxxxxxxx</li> </ul>"},{"location":"about/#license","title":"License","text":"<p>Coming soon.</p>"},{"location":"deploy/","title":"\u90e8\u7f72","text":"<p>\u8be5\u7ae0\u8282\u4ecb\u7ecd\u5982\u4f55\u5728\u4e0d\u540c\u5e73\u53f0\u8c03\u7528OPTIMake\u7684\u751f\u6210\u4ee3\u7801\u3002</p>"},{"location":"faq/","title":"FAQ","text":"<p>\u5982\u6709\u4efb\u4f55\u7591\u95ee\uff0c\u8bf7\u8054\u7cfboptimake@outlook.com</p>"},{"location":"index_bkup_180602/","title":"ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC","text":""},{"location":"index_bkup_180602/#introduction","title":"Introduction","text":"<p><code>ParNMPC</code> is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC). <code>ParNMPC</code> can utilize multiple CPU cores to solve the optimal control problem, and thus can be very fast (the computation time is usually in the range of \\mus).  The purpose of <code>ParNMPC</code> is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation and deployment.</p>"},{"location":"index_bkup_180602/#features","title":"Features","text":"<ul> <li>Symbolic problem representation</li> <li>Automatic parallel C/C++ code generation with OpenMP</li> <li>Fast rate of convergence (up to be superlinear)</li> <li>Highly parallelizable (capable of using at most N cores, N is the # of discretization steps)</li> <li>High speedup ratio</li> <li>MATLAB &amp; Simulink </li> </ul>"},{"location":"index_bkup_180602/#what-kind-of-problems-supported-in-parnmpc","title":"What Kind of Problems Supported in  <code>ParNMPC</code>?","text":"<p>The optimization control problem (OCP) supported in <code>ParNMPC</code> is defined as follows:</p> \\begin{align} \\min_{x(\\cdot),\\ u(\\cdot)}&amp;\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\ \\text{s.t.}\\quad &amp;x(0) = \\bar{x}_0,\\\\ &amp;M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\ &amp; C(u(t),x(t),p(t))=0,\\quad t\\in[0,T]. \\end{align} <p>Here,</p> Sign Size Description Sign Size Description u <code>[uDim,1]</code> Input vector L <code>[1,1]</code> Cost function x <code>[xDim,1]</code> State vector C <code>[muDim,1]</code> Equality constraint function p <code>[pDim,1]</code> Given parameter vector f <code>[xDim,1]</code> Dynamics T <code>[1,1]</code> Prediction horizon M <code>[xDim,1]</code> (Optional, e.g., Lagrange model) \\bar{x}_0 <code>[xDim,1]</code> Current state vector <p>Note</p> <ul> <li>NMPC with inequality constraints can be transfered into equality constrained problems. For detailed instructions, check Tips &gt; Handling Inequality Constraints.</li> <li>Varying dynamics, prediction horizon and references, and terminal cost function can be achieved by utilizing the parameter p.</li> </ul>"},{"location":"index_bkup_180602/#how-parnmpc-solves-the-ocp","title":"How <code>ParNMPC</code> Solves the OCP?","text":""},{"location":"index_bkup_180602/#discretization","title":"Discretization","text":"<p><code>ParNMPC</code>  discretizes the OCP defined above into the following problem with N steps:</p> \\begin{align} \\min_{X,\\ U}\\sum_{i=1}^{N}&amp;L(u_i,x_i,p_i) \\\\ \\text{s.t.}\\quad &amp; x_0 = \\bar{x}_0,\\\\ &amp;x_{i-1}+ F(u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\ &amp; C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}. \\end{align} <p>Here, the continuous-time state equation \\dot{x}(t)=f(u(t),x(t),p(t)) (if M is not imposed) is discretized using the reverse-time discretization method, e.g., the backward Euler's method with F(u_i,x_i,p_i) = f(u_i,x_i,p_i)\\Delta\\tau - x_i, where \\Delta\\tau=T/N.</p> <p>Note</p> <p>Higher order discretization methods such as the explicit Runge-Kutta method with order 4 can also be utilized in a reverse-time manner. </p>"},{"location":"index_bkup_180602/#karush-kuhn-tucker-kkt-conditions","title":"Karush-Kuhn-Tucker (KKT) conditions","text":"<p>Then, <code>ParNMPC</code> derives the KKT conditions for the discretized OCP as:</p> \\begin{align} &amp;x_{i-1}+F(u_{i},x_i,p_i)=0,\\ i\\in\\{1,\\cdots,N\\},\\\\ &amp;C(u_{i},x_i,p_i)=0,\\ i\\in\\{1,\\cdots,N\\},\\\\ &amp;H_{u}^{T}(\\lambda_{i},\\mu_{i},u_{i},x_{i},p_i)=0,\\ i\\in\\{1,\\cdots,N\\},\\\\ &amp;\\lambda_{i+1}+H_{x}^{T}(\\lambda_{i},\\mu_{i},u_{i},x_{i},p_i)=0,\\ i\\in\\{1,\\cdots,N\\}. \\end{align} <p>Here, \\lambda is the Lagrange multiplier for the state equation, \\mu is the Lagrange multiplier for the equality constraint, H(\\lambda,\\mu,u,x,p) = L(u,x,p)+\\lambda^{T}F(u,x,p)+\\mu^{T}C(u,x,p) is called the Hamiltonian, \\{p_i\\}_{i=1}^{N} are given, x_0=\\bar{x}_0, and \\lambda_{N+1}=0.</p>"},{"location":"index_bkup_180602/#solving-the-kkt-conditions-iteratively-in-parallel","title":"Solving the KKT conditions iteratively in parallel","text":"<p>Next, <code>ParNMPC</code> solves the KKT conditions iteratively in parallel for a given initial state \\bar{x}_0 and given parameters \\{p_i\\}_{i=1}^{N}. The NMPC controller is implemented by applying the first optimal control input u_1^* as the actual input.</p> <p>Note</p> <ul> <li>The iterative solver of <code>ParNMPC</code> relies on warm start. <code>ParNMPC</code> provides tools to solve the very first OCP offline.</li> <li><code>ParNMPC</code> provides tools to define the controlled plant model for simulation.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<ol> <li>Clone or download <code>OPTIMake Client</code> from Github: OPTIMake.</li> <li>Extract the downloaded file.</li> </ol>"},{"location":"interfaces/","title":"Interfaces","text":"<p>\u8be5\u7ae0\u8282\u4ecb\u7ecdOPTIMake\u652f\u6301\u7684\u95ee\u9898\u7c7b\u578b\uff0c\u4ee5\u53ca\u5982\u4f55\u901a\u8fc7OPTIMake\u63d0\u4f9b\u7684\u5efa\u6a21\u63a5\u53e3\u5b9a\u4e49\u95ee\u9898\u3002</p>"},{"location":"interfaces/#_1","title":"\u95ee\u9898\u652f\u6301","text":"<p>\u6211\u4eec\u9996\u5148\u8003\u8651\u5f62\u5f0f\u4e3a\u7684\u8fde\u7eed\u65f6\u95f4\u975e\u7ebf\u6027\u6700\u4f18\u63a7\u5236\u95ee\u9898:</p> \\begin{array}{cll} \\underset{x(\\cdot), z(\\cdot), u(\\cdot)}{\\operatorname{minimize}} &amp; \\int_{0}^{T} \\ell(x(t), z(t), u(t)) \\mathrm{d} t+M(x(T)) \\\\ \\text { subject to } &amp; x(0)=\\bar{x}_{0}, &amp; \\\\ &amp; 0=f(\\dot{x}(t), x(t), z(t), u(t)), &amp; t \\in[0, T], \\\\ &amp; 0 \\geq g(x(t), z(t), u(t)), &amp; t \\in[0, T] . \\end{array} <p>\u5728\u8fd9\u4e2a\u7b26\u53f7\u4e2d\uff0c\\mathbb{R} \\rightarrow \\mathbb{R}^{n_{x}} \u8868\u793a\u5fae\u5206\u72b6\u6001\uff0c\\mathbb{R} \\rightarrow \\mathbb{R}^{n_{z}} \u662f\u4ee3\u6570\u53d8\u91cf\uff0c\\mathbb{R} \\rightarrow \\mathbb{R}^{n_{u}} \u8868\u793a\u63a7\u5236\u8f93\u3002 \u6b64\u5916\uff0c\u6211\u4eec\u4f7f\u7528 \\ell: \\mathbb{R}^{n_{x}} \\times \\mathbb{R}^{n_{z}} \\times \\mathbb{R}^{n_{u}} \\rightarrow \\mathbb{R} \u8868\u793a\u62c9\u683c\u6717\u65e5\u9879\u6216\u8fc7\u7a0bcost\uff0cM:\\mathbb{R} \\rightarrow \\mathbb{R}^{n_{x}} \u8868\u793aMayer\u9879\u6216\u7ec8\u7aefcost\u3002 \u52a8\u529b\u5b66\u6a21\u578b\u91c7\u7528\u4e00\u7ec4\u53f3\u4fa7\u4e3a f: \\mathbb{R}^{n_{x}} \\times \\mathbb{R}^{n_{x}} \\times \\mathbb{R}^{n_{z}} \\times\\mathbb{R}^{n_{u}} \\rightarrow \\mathbb{R}^{n_{x}} \\times \\mathbb{R}^{n_{z}}\u7684\u9690\u5f0f\u5fae\u5206\u4ee3\u6570\u65b9\u7a0b(DAE)\u3002 \u5176\u4f59\u90e8\u5206\uff0c\u6211\u4eec\u5047\u8bbe\u9690\u5f0fDAE\u7684\u7d22\u5f15\u4e3a1\uff0c\u5373\uff0c\\partial f /(\\partial \\dot{x}, \\partial z) \u3002 \u975e\u7ebf\u6027\u8def\u5f84\u7ea6\u675f\u7531g: \\mathbb{R}^{n_{x}} \\times \\mathbb{R}^{n_{z}} \\times \\mathbb{R}^{n_{u}} \\rightarrow \\mathbb{R}^{n_{g}} \u7ed9\u51fa\uff0c\u5e76\u4e14\u72b6\u6001\u7684\u521d\u59cb\u503c\u662f\\bar{x}_{0} \\in \\mathbb{R}^{n_{x}} \u3002</p> <ul> <li>Multiple shooting \u79bb\u6563</li> </ul> <p>\u5728OPTIMake\u4e2d\uff0c\u6211\u4eec\u7528Multi-Shooting\u65b9\u6cd5\u79bb\u6563\u975e\u7ebf\u6027\u6700\u4f18\u63a7\u5236\u95ee\u9898\u3002 \u6211\u4eec\u5f15\u5165\u4e86\u4e00\u4e2a\u65f6\u95f4\u79bb\u6563\u70b9\u5217 [t_0\uff0ct_1r,...,t_N] ( t_k\uff1ct_{k+1}\uff0ck=0\uff0c...\uff0cN\u22121 )\uff0c \u79bb\u6563\u72b6\u6001\u53d8\u91cf x_0,...,x_N \uff0c\u4ee3\u6570\u53d8\u91cf z_0,...,z_{N\u22121}\u5e76\u63a7\u5236 u_0,... \uff0c\u5bf9\u4e8e\u63a7\u5236\u8f68\u8ff9\uff0c\u6211\u4eec\u9009\u62e9\u5206\u6bb5\u5e38\u6570\u63a7\u5236\u53c2\u6570\u5316\u3002 \u5728\u6bcf\u4e2a\u65f6\u95f4\u95f4\u9694 [t_k,t_{k+1})\u4e0a\uff0c\u7cfb\u7edf\u8fc7\u7a0b\u8868\u793a\u4e3a\uff1a</p> \\begin{equation} \\begin{bmatrix}   x_{k+1}\\\\  z_k \\end{bmatrix} = \\phi(x_k,z_k), \\ k = 0,...,N-1 \\end{equation} <p>\u5982 [1]_ \u6240\u793a\uff0c\u4e0e\u6309\u6b63\u5411\u987a\u5e8f\u6267\u884c\u52a8\u6001\u8fc7\u7a0b\u5e76\u8fdb\u884c\u4f18\u5316\u7684single shooting\u76f8\u6bd4\uff0cmulti-shooting\u65b9\u6cd5\u901a\u5e38\u53ef\u4ee5\u5e26\u6765\u66f4\u597d\u7684\u6536\u655b\u884c\u4e3a\u3002 \u5f97\u5230\u7684\u975e\u7ebf\u6027\u89c4\u5212\uff08NLP\uff09\u516c\u5f0f\u5982\u4e0b\u6240\u793a\uff1a</p> \\begin{aligned} \\underset{\\substack{x_{0}, \\ldots, x_{N}, \\\\ z_{0}, \\ldots, z_{N-1}, \\\\ u_{0}, \\ldots, u_{N-1}}}{\\operatorname{minimize}} &amp; \\sum_{k=0}^{N-1}\\left(t_{k+1}-t_{k}\\right) \\cdot \\ell\\left(x_{k}, z_{k}, u_{k}\\right)+M\\left(x_{N}\\right) \\\\ \\text { subject to } &amp; x_{0}=\\bar{x}_{0}, \\\\ {\\left[\\begin{array}{c} x_{k+1} \\\\ z_{k} \\end{array}\\right] } &amp; =\\phi_{k}\\left(x_{k}, u_{k}\\right), \\quad k=0, \\ldots, N-1, \\\\ 0 &amp; \\geq g_{k}\\left(x_{k}, z_{k}, u_{k}\\right) \\quad k=0, \\ldots, N-1 . \\end{aligned} <p>[1] Bock, H.: Randwertproblemmethoden zur Parameteridentifizierung in Systemen nichtlinearer Differentialgleichungen, Bonner Mathematische Schriften, vol. 183. Universit\u00e4t Bonn, Bonn (1987)</p> <ul> <li> <p>OPTIMake\u6c42\u89e3\u4ee5\u4e0b\u7684\u4f18\u5316\u95ee\u9898\uff1a</p> \\begin{equation*}     \\begin{split}        &amp;\\quad \\quad \\quad \\min_{v_1,\\cdots,v_N} \\sum_{i=1}^{N} l(v_i, p_i) \\\\         &amp;\\begin{split}             \\text{subject to}             &amp;\\quad  v_1(\\mathcal{S}) = v_{start},\\\\             &amp;\\quad  f(v_{i}, v_{i+1}, p_i) = 0,\\quad i=1,\\cdots,N - 1,\\\\             &amp;\\quad  v_N(\\mathcal{E}) = v_{end},\\\\             &amp;\\quad  g(v_i, p_i) \\geq 0,\\quad i=1,\\cdots,N.         \\end{split}     \\end{split} \\end{equation*} </li> </ul> <p>\u8be5\u4f18\u5316\u95ee\u9898\u4e3a\u4e00\u4e2a\u5177\u6709 N \u4e2astage\u7684\u4f18\u5316\u95ee\u9898\uff0c\u53d6\u51b3\u4e8e\u95ee\u9898\uff0c\u8be5\u4f18\u5316\u95ee\u9898\u53ef\u80fd\u4e3a\u4e00\u4e2a\u975e\u7ebf\u6027\u975e\u51f8\u7684\u4f18\u5316\u95ee\u9898\u3002 \u5176\u4e2d\uff0c v_1,\\cdots,v_N \\in \\mathbb{R}^{n_{v}} \u4e3a\u4f18\u5316\u53d8\u91cf\uff1b p_1,\\cdots,p_N\\in \\mathbb{R}^{n_{p}} \u4e3a\u53c2\u6570\uff1b l\uff1a\\mathbb{R}^{n_{v}} \\times \\mathbb{R}^{n_{p}} \\rightarrow \\mathbb{R} \u4e3astage cost\uff1b f\uff1a\\mathbb{R}^{n_{v}} \\times \\mathbb{R}^{n_{v}} \\times \\mathbb{R}^{n_{p}} \\rightarrow \\mathbb{R}^{n_{f}} \u4e3a\u7b49\u5f0f\u7ea6\u675f\uff1b g\uff1a\\mathbb{R}^{n_{v}} \\times \\mathbb{R}^{n_{p}} \\rightarrow \\mathbb{R}^{n_{g}} \u4e3a\u4e0d\u7b49\u5f0f\u7ea6\u675f\uff1b  v_{start} \u4e3a\u521d\u59cb\u7684\u503c\uff08\\mathcal{S} \u4e3a\u88ab\u56fa\u5b9a\u7684\u521d\u59cb\u53d8\u91cf\u7684index\uff09\uff1b  v_{end} \u4e3a\u7ec8\u70b9\u7684\u503c\uff08\\mathcal{E} \u4e3a\u88ab\u56fa\u5b9a\u7684\u7ec8\u70b9\u53d8\u91cf\u7684index\uff09\u3002</p>"},{"location":"interfaces/#_2","title":"\u95ee\u9898\u5b9a\u4e49","text":"<p>\u4e0b\u9762\u4e3a\u5b9a\u4e49\u95ee\u9898\u7684\u4f8b\u5b50\uff1a</p> <pre><code>prob = multi_stage_problem(name='vehicle', N=10)\n</code></pre> <p>\u5176\u4e2d\uff0c\u51fd\u6570\u5165\u53c2\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <ul> <li> <p>name: str     \u95ee\u9898\u7684\u540d\u79f0\uff0c\u8be5\u540d\u79f0\u4f1a\u7528\u5728\u751f\u6210\u4ee3\u7801\u7684\u6587\u4ef6\u540d\uff0c\u51fd\u6570\u540d\u7b49\u3002</p> </li> <li> <p>N: int     \u95ee\u9898\u7684stage\u6570\u76ee\uff0c\u5fc5\u987b\u5927\u4e8e\u7b49\u4e8e1\u3002</p> </li> </ul>"},{"location":"interfaces/#parameter","title":"parameter\u5b9a\u4e49","text":"<p>parameter\u4e3a\u5728\u4f18\u5316\u8fc7\u7a0b\u4e2d\u4e0d\u53d8\u7684\u91cf\uff0c\u7531\u7528\u6237\u5728\u8c03\u7528\u6c42\u89e3\u524d\u7ed9\u5b9a\uff0c\u6bd4\u5982\u8f66\u8eab\u957f\u5ea6length\uff0c\u8d28\u91cfmass\u3002</p> <p>OPTIMake\u652f\u6301\u4e24\u79cd\u7c7b\u578b\u7684parameter\uff1astage-independent parameter\u4e0estage-dependent parameter\u3002 stage-dependent parameter\u5728\u4e0d\u540cstage\u53ef\u4ee5\u6709\u4e0d\u540c\u7684\u503c\uff0c \u800cstage-independent parameter\u5728\u6240\u6709stage\u7684\u503c\u90fd\u4e00\u81f4\uff08\u53ef\u4ee5\u8282\u7ea6\u5b58\u50a8\u4e0e\u7b80\u5316\u8bbe\u7f6e\uff09\u3002</p> <p>\u4e0b\u9762\u4e3a\u5b9a\u4e49\u4f18\u5316\u53d8\u91cf\u7684\u4f8b\u5b50\uff1a</p> <pre><code>length = prob.parameter(name='length', stage_dependent=False)\nmass = prob.parameter('mass')\nxLowerBound = prob.parameter('xLowerBound', stage_dependent=True)\n</code></pre> <p>\u5176\u4e2d\uff0c\u51fd\u6570\u5165\u53c2\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <ul> <li> <p>name: str     parameter\u7684\u540d\u79f0\u3002</p> </li> <li> <p>stage_dependent: bool, optional     parameter\u662f\u5426\u4e3astage-dependent\u3002     \u9ed8\u8ba4\u503c\u4e3aTrue\uff0c\u8868\u793aparameter\u4e3astage-dependent\u3002</p> </li> </ul> <p>\u4ea6\u6216\u8005\u901a\u8fc7list\u7684\u65b9\u5f0f\u5b9a\u4e49\uff1a</p> <pre><code>length, mass, xLowerBound = prob.parameters(['length', 'mass', 'xLowerBound'], stage_dependent=False)\n</code></pre>"},{"location":"interfaces/#_3","title":"\u4f18\u5316\u53d8\u91cf\u5b9a\u4e49","text":"<p>\u4f18\u5316\u53d8\u91cf\u4e3a\u5728\u4f18\u5316\u8fc7\u7a0b\u4e2d\u53d8\u5316\u7684\u91cf\uff0c\u6bd4\u5982\u8f66\u8f86\u7684\u8f6c\u89d2\u63a7\u5236\u91cfdelta\uff0c\u4f4d\u7f6e\u72b6\u6001x\uff0cy\u3002 \u5728\u5b9a\u4e49\u4f18\u5316\u53d8\u91cf\u65f6\uff0c\u53ef\u4ee5\u540c\u65f6\u5b9a\u4e49\u4f18\u5316\u53d8\u91cf\u7684\u786c\u8fb9\u754c\u3001\u8f6f\u8fb9\u754c\u4ee5\u53ca\u8fdd\u53cd\u8f6f\u8fb9\u754c\u65f6\u7684\u60e9\u7f5a\u3002</p> <p>\u4e0b\u9762\u4e3a\u5b9a\u4e49\u4f18\u5316\u53d8\u91cf\u7684\u4f8b\u5b50\uff1a</p> <pre><code>delta = prob.variable(name='delta', hard_lowerbound=-0.5, hard_upperbound=0.5)\n\n# xLowerBound\u4e0exUpperBound\u4e3a\u5df2\u5b9a\u4e49\u7684parameter\nx = prob.variable('x', hard_lowerbound=xLowerBound, hard_upperbound=xUpperBound, soft_lowerbound=-0.2, soft_upperbound=0.2, weight_soft_lowerbound=100.0, weight_soft_upperbound=100.0, penalty_type_soft_lowerbound='quadratic', penalty_type_soft_upperbound='l1')\ny = prob.variable('y')\n</code></pre> <p>\u4ea6\u6216\u8005\u901a\u8fc7list\u7684\u65b9\u5f0f\u5b9a\u4e49\uff1a</p> <pre><code>delta, x, y = prob.variables(name=['delta', 'x', 'y'], \n              hard_lowerbound=[-0.5, xLowerBound, None], hard_upperbound=[0.5, xUpperBound, None],\n              soft_lowerbound=[None, -0.2, None], soft_upperbound=[None, 0.2, None],\n              weight_soft_lowerbound=[None, 100.0, None], weight_soft_upperbound=[None, 100.0, None],\n              penalty_type_soft_lowerbound=['quadratic', 'quadratic', 'quadratic'],\n              penalty_type_soft_upperbound=['quadratic', 'l1', 'quadratic'])\n</code></pre> <p>\u5176\u4e2d\uff0c\u51fd\u6570\u5165\u53c2\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <ul> <li> <p>name: str     \u4f18\u5316\u53d8\u91cf\u7684\u540d\u79f0\u3002</p> </li> <li> <p>hard_lowerbound: float\u6216\u53c2\u6570, optional     \u786c\u4e0b\u754c\uff0c\u5373\u4f18\u5316\u53d8\u91cf\u7684\u6700\u5c0f\u503c\u3002     \u9ed8\u8ba4\u503c\u4e3a-inf\uff0c\u8868\u793a\u65e0\u4e0b\u754c\u3002  </p> </li> <li> <p>hard_upperbound: float\u6216\u53c2\u6570, optional     \u786c\u4e0a\u754c\uff0c\u5373\u4f18\u5316\u53d8\u91cf\u7684\u6700\u5927\u503c\u3002     \u9ed8\u8ba4\u503c\u4e3ainf\uff0c\u8868\u793a\u65e0\u4e0a\u754c\u3002</p> </li> <li> <p>soft_lowerbound: float\u6216\u53c2\u6570, optional     \u8f6f\u4e0b\u754c\uff0c\u5373\u4f18\u5316\u53d8\u91cf\u7684\u6700\u5c0f\u503c\u3002     \u9ed8\u8ba4\u503c\u4e3a-inf\uff0c\u8868\u793a\u65e0\u4e0b\u754c\u3002</p> </li> <li> <p>soft_upperbound: float\u6216\u53c2\u6570, optional     \u8f6f\u4e0a\u754c\uff0c\u5373\u4f18\u5316\u53d8\u91cf\u7684\u6700\u5c0f\u503c\u4e0e\u6700\u5927\u503c\u3002     \u9ed8\u8ba4\u503c\u4e3ainf\uff0c\u8868\u793a\u65e0\u4e0b\u754c\u4e0e\u4e0a\u754c\u3002</p> </li> <li> <p>weight_soft_lowerbound: float\u6216\u53c2\u6570, optional     \u8f6f\u4e0b\u754c\u7684\u60e9\u7f5a\u6743\u91cd\uff0c\u5fc5\u987b\u4e3a\u975e\u8d1f\u3002     \u9ed8\u8ba4\u503c\u4e3a0.0\uff0c\u8868\u793a\u65e0\u60e9\u7f5a\u3002</p> </li> <li> <p>weight_soft_upperbound: float\u6216\u53c2\u6570, optional     \u8f6f\u4e0b\u754c\u7684\u60e9\u7f5a\u6743\u91cd\uff0c\u5fc5\u987b\u4e3a\u975e\u8d1f\u3002     \u9ed8\u8ba4\u503c\u4e3a0.0\uff0c\u8868\u793a\u65e0\u60e9\u7f5a\u3002</p> </li> <li> <p>penalty_type_soft_lowerbound: str, optional     \u8f6f\u4e0b\u754c\u7684\u60e9\u7f5a\u7c7b\u578b\uff0c\u53ef\u9009\u503c\u4e3a'quadratic'\u6216'l1'\u3002     \u9ed8\u8ba4\u503c\u4e3a'quadratic'\u3002</p> </li> <li> <p>penalty_type_soft_upperbound: str, optional     \u8f6f\u4e0a\u754c\u7684\u60e9\u7f5a\u7c7b\u578b\uff0c\u53ef\u9009\u503c\u4e3a'quadratic'\u6216'l1'\u3002     \u9ed8\u8ba4\u503c\u4e3a'quadratic'\u3002</p> </li> </ul>"},{"location":"interfaces/#cost","title":"cost\u5b9a\u4e49","text":""},{"location":"interfaces/#_4","title":"\u7b49\u5f0f\u7ea6\u675f\u5b9a\u4e49","text":""},{"location":"interfaces/#_5","title":"\u4e0d\u7b49\u5f0f\u7ea6\u675f\u5b9a\u4e49","text":""},{"location":"interfaces/#_6","title":"\u8d77\u70b9\u7ea6\u675f\u5b9a\u4e49","text":"<p>\u8d77\u70b9\u7ea6\u675f\u63cf\u8ff0\u4e86\u7b2c\u4e00\u4e2a\u4f18\u5316\u53d8\u91cf :math:<code>v_1</code> \u662f\u5426\u4e3a\u56fa\u5b9a\u503c\uff0c\u6bd4\u5982\u5728\u8f66\u8f86\u8f68\u8ff9\u89c4\u5212\u95ee\u9898\u4e2d\u7684\u8f66\u8f86\u521d\u59cb\u72b6\u6001\u7ea6\u675f\u3002</p> <p>\u4e0b\u9762\u4e3a\u5b9a\u4e49\u8d77\u70b9\u7ea6\u675f\u7684\u4f8b\u5b50\uff1a</p> <p>.. code-block:: python</p> <pre><code># x0, y0, phi0\u4e3a\u5df2\u5b9a\u4e49\u7684parameter\nprob.fixed_start_variable(var=x, value=x0)\nprob.fixed_start_variable(y, y0)\nprob.fixed_start_variable(phi, phi0)\n</code></pre> <p>\u5176\u4e2d\uff0c\u51fd\u6570\u5165\u53c2\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <ul> <li> <p>var: \u4f18\u5316\u53d8\u91cf     \u9700\u8981\u5728\u8d77\u70b9\u56fa\u5b9a\u7684\u4f18\u5316\u53d8\u91cf\u3002</p> </li> <li> <p>value: float\u6216\u53c2\u6570     \u8d77\u70b9\u4f18\u5316\u53d8\u91cf\u7684\u503c\u3002</p> </li> </ul>"},{"location":"interfaces/#_7","title":"\u7ec8\u70b9\u7ea6\u675f\u5b9a\u4e49","text":"<p>\u7ec8\u70b9\u7ea6\u675f\u63cf\u8ff0\u4e86\u6700\u540e\u4e00\u4e2a\u4f18\u5316\u53d8\u91cfv_N\u662f\u5426\u4e3a\u56fa\u5b9a\u503c\uff0c\u6bd4\u5982\u5728\u706b\u7bad\u7740\u9646\u8f68\u8ff9\u89c4\u5212\u95ee\u9898\u4e2d\u7684\u672b\u7aef\u96f6\u901f\u5ea6\u7ea6\u675f\u3002</p> <p>\u4e0b\u9762\u4e3a\u5b9a\u4e49\u7ec8\u70b9\u7ea6\u675f\u7684\u4f8b\u5b50\uff1a</p> <pre><code># x0, y0, phi0\u4e3a\u5df2\u5b9a\u4e49\u7684parameter\nprob.fixed_start_variable(var=v, value=0.0)\nprob.fixed_start_variable(phi, 0.0)\n</code></pre> <p>\u5176\u4e2d\uff0c\u51fd\u6570\u5165\u53c2\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <ul> <li> <p>var: \u4f18\u5316\u53d8\u91cf     \u9700\u8981\u5728\u7ec8\u70b9\u56fa\u5b9a\u7684\u4f18\u5316\u53d8\u91cf\u3002</p> </li> <li> <p>value: float\u6216\u53c2\u6570     \u7ec8\u70b9\u4f18\u5316\u53d8\u91cf\u7684\u503c\u3002</p> </li> </ul>"},{"location":"tips/","title":"Tips","text":""},{"location":"tips/#solving-the-very-first-ocp","title":"Solving the Very First OCP","text":"<p>In most of the cases, the very first OCP can be solved offline so that warm-start can be used. In solving the very first OCP offline, you can start with an easy-to-solve OCP, for example, OCP with less constraints or mild parameters.  Then, you can gradually modify and solve the OCP to the one you want by starting from the solution obtained before.</p>"},{"location":"tips/#degree-of-parallelism-dop","title":"Degree of Parallelism (DoP)","text":"<p><code>DoP</code> is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller <code>DoP</code>. In the case of <code>DoP=1</code>, the solver is exactly equivalent to the interior-point method.</p> <p>Meanwhile, when you want to generate serial code without any parallel computing, you can set <code>DoP</code> to 1 and edit <code>Timer.m</code> to specify your own timer function (the default is <code>omp_get_wtime</code>, which is not supported when OpenMP is disabled).</p>"},{"location":"tips/#tuning","title":"Tuning","text":"<ul> <li>Specify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.</li> </ul>"},{"location":"examples/exp_damper/","title":"Semi-active Damper","text":"<p>Example</p> <p><code>SemiActiveDamper/</code></p>"},{"location":"examples/exp_damper/#problem-description","title":"Problem Description","text":"<p>A vehicle contacts the wall through the spring and damper: </p> <p> </p> <ul> <li> <p>The state vector of the system is x=[y,\\dot{y}]^T, where y is the position of the vehicle. </p> </li> <li> <p>The input is the damping coefficient d, which is constrained with  0\\leq d \\leq 1.</p> </li> <li> <p>The dynamic equation of this semi-active damper is m\\ddot{y} = -ky-d\\dot{y}, where k = 1 and m=1.</p> </li> </ul> <p>The task is to control the vehicle's position y to 0 from an initial position.</p>"},{"location":"examples/exp_damper/#ocp-in-optimake","title":"OCP in <code>OPTIMake</code>","text":"<p>The inequality constraints are transfered into equality constraints by introducing an extra dummy input d_s. </p> <p>The underlying OCP defined in <code>OPTIMake</code> is formulated as:</p> <ul> <li>State: x=[y,\\dot{y}]^T.</li> <li>Input: u=[d,d_s].</li> <li>Parameter: p is empty.</li> <li>L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s.</li> <li>C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4}.</li> <li>f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T.</li> <li>Prediction horizon T=5.</li> <li>Number of the discritization grids N=48.</li> <li>Discretization method: Euler.</li> </ul>"},{"location":"examples/exp_damper/#closed-loop-simulation-using-optimake","title":"Closed-loop Simulation using <code>OPTIMake</code>","text":""},{"location":"examples/exp_damper/#step-1-nmpc-problem-formulation","title":"Step 1. NMPC problem formulation","text":"<p>See Workflow of OPTIMake &gt; NMPC Problem Formulation.</p> <p>Example</p> <p><code>SemiActiveDamper/NMPC_Problem_Formulation.m</code></p>"},{"location":"examples/exp_damper/#step-2-code-generation-and-deployment-in-simulink","title":"Step 2. Code generation and deployment in Simulink","text":"<p>See Workflow of OPTIMake &gt; Code Generation and Deployment &gt; Simulink.</p> <ol> <li> <p>Code generation</p> <p>Example</p> <p><code>SemiActiveDamper/Simu_Simulink_Setup.m</code></p> </li> <li> <p>Deployment</p> <p>Example</p> <p><code>SemiActiveDamper/Simu_Simulink.slx</code></p> </li> </ol>"},{"location":"examples/exp_double_pendulum/","title":"Double Inverted Pendulum on a Cart","text":"<p>Example</p> <p><code>DoubleInvertedPendulum/</code></p> <p>Where you can find this pendulum</p> <p>A. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004.</p>"},{"location":"examples/exp_double_pendulum/#problem-description","title":"Problem Description","text":"<p>Swing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity.  The pendulum we want to swing up is:</p> <p> </p> <ul> <li> <p>The state vector of the system is x =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T}, where \\theta_0 is the displacement of the cart, and where \\theta_1, \\theta_2 are the pendulum angles.</p> </li> <li> <p>The control force u is constrained with  |u|\\leq 10.</p> </li> <li> <p>The system is modeled as D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu with \\theta=[\\theta_0,\\theta_1,\\theta_2]^T.</p> </li> <li> <p>A terminal penalty function is imposed to swing up the pendulum.</p> </li> </ul> <p>The task is to swing up the pendulum from the initial state x_0 =  [0,\\pi,\\pi,0,0,0]^{T}.</p>"},{"location":"examples/exp_double_pendulum/#ocp-in-optimake","title":"OCP in <code>OPTIMake</code>","text":"<p>The underlying OCP defined in <code>OPTIMake</code> is formulated as:</p> <ul> <li>State: x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T.</li> <li>Input: u with u_{max} = 10 and u_{min} = -10.</li> <li>Parameter: p=[Q_d,R_d,\\gamma].</li> <li> <p>L(u,x,p)  = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2 with Q=\\text{diag}(Q_d) and R=\\text{diag}(R_d).</p> </li> <li> <p>f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}].</p> </li> <li> <p>M(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta)).</p> </li> <li> <p>Prediction horizon T=1.5.</p> </li> <li>Number of the discritization grids N=48.</li> <li>Discretization method: Euler.</li> </ul>"},{"location":"examples/exp_double_pendulum/#closed-loop-simulation-using-optimake","title":"Closed-loop Simulation using <code>OPTIMake</code>","text":""},{"location":"examples/exp_double_pendulum/#step-1-nmpc-problem-formulation","title":"Step 1. NMPC problem formulation","text":"<p>See Workflow of OPTIMake &gt; NMPC Problem Formulation.</p> <p>Example</p> <p><code>DoubleInvertedPendulum/NMPC_Problem_Formulation.m</code></p>"},{"location":"examples/exp_double_pendulum/#step-2-code-generation-and-deployment-in-simulink","title":"Step 2. Code generation and deployment in Simulink","text":"<p>See Workflow of OPTIMake &gt; Code Generation and Deployment &gt; Simulink.</p> <ol> <li> <p>Code generation</p> <p>Example</p> <p><code>DoubleInvertedPendulum/Simu_Simulink_Setup.m</code></p> </li> <li> <p>Deployment</p> <p>Example</p> <p><code>DoubleInvertedPendulum/Simu_Simulink.slx</code></p> </li> </ol>"},{"location":"examples/exp_heli/","title":"Helicopter","text":"<p>Example</p> <p><code>Helicopter/</code></p> <p>Where you can find this helicopter</p> <p>Quanser website. 3 DoF Helicopter.  Model: Benchmark model of Quanser\u2019s 3 DOF Helicopter - 2018 </p>"},{"location":"examples/exp_heli/#problem-description","title":"Problem Description","text":"<ul> <li> <p>The state vector of the helicopter is x =  [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6}, where q = [\\epsilon,\\rho,\\lambda]^T is the vector of the elevation angle, pitch angle, and yaw angle. The pitch angle \\rho is set to be |\\rho|\\leq 1.</p> </li> <li> <p>The input vector is u=[V_f,V_b]^T, where V_f is the voltage on the front motor and  V_b is the voltage on the back motor. The control input is bounded by [0,0]^T \\leq u \\leq [20,20]^T.</p> </li> <li> <p>The dynamics of the helicopter are given by the following equations:</p> </li> </ul> \\begin{align*} \\ddot{q}  = &amp;-\\left[ \\begin{array}{c} \\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\  -a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\  0 \\end{array}  \\right] - \\left[ \\begin{array}{ccc} C_\\epsilon &amp;  &amp;  \\\\  &amp;  C_\\rho&amp;  \\\\  &amp;  &amp; C_\\lambda \\end{array}  \\right]\\dot{q}\\\\ &amp;+K_f \\left[ \\begin{array}{cc} b_{\\epsilon}\\cos(\\rho)&amp; 0 \\\\  0 &amp;  b_{\\rho}\\\\  b_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)&amp; 0 \\end{array}  \\right]u \\end{align*} <p>The task is to control the helicopter to track a given yaw reference.</p>"},{"location":"examples/exp_heli/#ocp-in-optimake","title":"OCP in <code>OPTIMake</code>","text":"<p>The state constraints are softened by introducing a slack variable \\rho_s.</p> <p>The underlying OCP defined in <code>OPTIMake</code> is formulated as:</p> <ul> <li>State: x=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T.</li> <li>Input: u=[V_f,V_b,\\rho_s]^T with u_{max}=[20,20,\\infty]^T and u_{min} = [0,0,0]^T.</li> <li>Parameter: p=[Q_d,R_d,x_{ref},\\gamma]^T, where Q_d and R_d are tuning parameters, x_{ref} is the varying reference, and \\gamma&gt;0 is the barrier parameter.</li> <li>Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p), where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2 and L_{penalty}(u,x,p)=1000\\rho_s^2 is the penalty function.</li> <li>Polytopic function (linear constraint): G = [\\rho - \\rho_s, \\rho + \\rho_s]^T with G_{max}=[1,\\infty]^T and G_{min} = [-\\infty,-1]^T.</li> <li>f(u,x,p) is shown before.</li> <li>Prediction horizon T=4 s.</li> <li>Number of the discritization grids N=48.</li> <li>Discretization method: Euler.</li> </ul> <p>Experiment settings:</p> <ul> <li>CPU: i7-8700K.</li> <li>MATLAB R2015b + Microsoft Visual C++ 2015 (C)</li> <li>Tolerance: 1e-4.</li> <li>DoP: 4.</li> <li>Hessian approximation method: Newton.</li> </ul>"},{"location":"examples/exp_heli/#closed-loop-control-using-optimake","title":"Closed-loop control using <code>OPTIMake</code>","text":""},{"location":"examples/exp_heli/#step-1-nmpc-problem-formulation","title":"Step 1. NMPC problem formulation","text":"<p>See Workflow of OPTIMake &gt; NMPC Problem Formulation.</p> <p>Example</p> <p><code>Helicopter/NMPC_Problem_Formulation.m</code></p>"},{"location":"examples/exp_heli/#step-2-code-generation-and-deployment-in-simulink","title":"Step 2. Code generation and deployment in Simulink","text":"<p>See Workflow of OPTIMake &gt; Code Generation and Deployment &gt; Simulink.</p> <ol> <li> <p>Code generation</p> <p>Example</p> <p><code>Helicopter/Simulink_Setup.m</code></p> </li> <li> <p>Deployment</p> <p>Example</p> <p><code>Helicopter/Deploy_Simulink_R2015b.slx</code></p> <p>Add <code>-openmp</code> to the makefile provided by Quanser.</p> </li> </ol> <p>Experiment results (left: first 15 seconds; right: last 15 seconds):</p> <p> </p> <p> </p> <p> </p>"},{"location":"examples/exp_quadrotor/","title":"Quadrotor","text":"<p>Example</p> <p><code>Quadrotor/</code></p> <p>Where you can find this quadrotor</p> <p>M. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d  ICRA, Shanghai, China, 2011, pp. 763\u2013770.</p>"},{"location":"examples/exp_quadrotor/#problem-description","title":"Problem Description","text":"<ul> <li> <p>The state vector of the quadrotor is x =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9}, where (X,Y,Z) and (\\gamma,\\beta,\\alpha) are the position and angles of the quadrotor, respectively. The state is bounded by [-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T.</p> </li> <li> <p>The input vector is u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T, where a represents the thrust and (\\omega_{X},\\omega_{Y},\\omega_{Z}) the rotational rates. The control input is bounded by [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T. </p> </li> <li> <p>The dynamics of the quadrotor are given by the following equations:</p> </li> </ul> \\begin{align} &amp;\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ &amp;\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ &amp;\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ &amp;\\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ &amp;\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ &amp;\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z} \\end{align} <p>The task is to control the quadrotor to track a given position reference under a variable prediction horizon.</p>"},{"location":"examples/exp_quadrotor/#ocp-in-optimake","title":"OCP in <code>OPTIMake</code>","text":"<p>The state constraints are softened by introducing slack variables \\dot{X}_s, \\dot{Y}_s, and \\dot{Z}_s.</p> <p>The underlying OCP defined in <code>OPTIMake</code> is formulated as:</p> <ul> <li>State: x=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T.</li> <li>Input: u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T with u_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T and u_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T.</li> <li>Parameter: p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T, where \\gamma&gt;0 is the barrier parameter.</li> <li>Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p), where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 with x_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T, and L_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2) is the penalty function.</li> <li>Polytopic function (linear constraint): G = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T with G_{max}=[1,\\infty,1,\\infty,1,\\infty]^T and G_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T.</li> <li>f(u,x,p) is shown before.</li> <li>Prediction horizon T.</li> <li>Number of the discritization grids N=40.</li> <li>Discretization method: Euler.</li> </ul>"},{"location":"examples/exp_quadrotor/#closed-loop-simulation-using-optimake","title":"Closed-loop Simulation using <code>OPTIMake</code>","text":""},{"location":"examples/exp_quadrotor/#step-1-nmpc-problem-formulation","title":"Step 1. NMPC problem formulation","text":"<p>See Workflow of OPTIMake &gt; NMPC Problem Formulation.</p> <p>Example</p> <p><code>Quadrotor/NMPC_Problem_Formulation.m</code></p>"},{"location":"examples/exp_quadrotor/#step-2-code-generation-and-deployment-in-simulink","title":"Step 2. Code generation and deployment in Simulink","text":"<p>See Workflow of OPTIMake &gt; Code Generation and Deployment &gt; Simulink.</p> <ol> <li> <p>Code generation</p> <p>Example</p> <p><code>Quadrotor/Simu_Simulink_Setup.m</code></p> </li> <li> <p>Deployment</p> <p>Example</p> <p><code>Quadrotor/Simu_Simulink.slx</code></p> </li> </ol>"},{"location":"examples/exp_single_pendulum/","title":"Single Inverted Pendulum on a Cart","text":"<p>Coming soon.</p>"},{"location":"examples/exp_vehicle/","title":"Vehicle","text":"<p>Example</p> <p><code>Vehicle/</code></p>"},{"location":"examples/exp_vehicle/#problem-description","title":"Problem Description","text":"<ul> <li> <p>The state vector of the vehicle is x =  [y,z  , v ,\\theta]^{T}\\in\\mathbb{R}^{4}, where (y,z) is the position coordinate, v is the velocity, and \\theta is the heading angle. </p> </li> <li> <p>The input vector is u=[F,s]^T, where F is the acceleration force and s is the steering torque. The control input is bounded by [-5,-1]^T \\leq u \\leq [5,1]^T.</p> </li> <li> <p>The vehicle starts from position (-2,0). It's aim is to reach (3.5,2) while avoiding two obstacles with positions (0,0) and (2,2). These constraints are formulated as y^2+z^2\\geq 1 and (y-2)^2+(z-2)^2\\geq 1.</p> </li> <li> <p>The dynamics of the vehicle are given by the following equations (m: mass and I: moment of inertia):</p> </li> </ul> \\begin{align} &amp;\\dot{y} = v\\cos(\\theta)\\\\ &amp;\\dot{z} = v\\sin(\\theta)\\\\ &amp;\\dot{v} = F/m\\\\ &amp;\\dot{\\theta}  =  s/I \\end{align}"},{"location":"examples/exp_vehicle/#ocp-in-optimake","title":"OCP in <code>OPTIMake</code>","text":"<p>First, the state constraints are transfered into y^2+z^2 =  C_{s1} and (y-2)^2+(z-2)^2 =  C_{s2} with C_{s1}\\geq 1 and C_{s2}\\geq 2. Next, C_{s1}\\geq 1 and C_{s2}\\geq 2 are softened by introducing slack variables C_{ss1} and C_{ss2}.</p> <p>The underlying OCP defined in <code>OPTIMake</code> is formulated as:</p> <ul> <li>State: x=[y,z  , v ,\\theta]^T.</li> <li>Input: u=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T with u_{max}=[5,  1,  \\infty, \\infty,  \\infty, \\infty]^T and u_{min} = [-5, -1, -\\infty, 0,   -\\infty, 0 ]^T.</li> <li>Parameter: p=\\gamma, where \\gamma&gt;0 is the barrier parameter.</li> <li>Equality constraint C(u,x,p) = [y^2    + z^2     - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T.</li> <li>Cost function L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p), where L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 with x_{ref}=[3.5,2,0,0], and L_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2) is the penalty function.</li> <li>Polytopic function (linear constraint) G = [C_{s1} - C_{ss1},C_{s1} + C_{ss1},     C_{s2} - C_{ss2},     C_{s2} + C_{ss2}]^T with G_{max}=[\\infty,\\infty,\\infty,\\infty]^T and G_{min} = [-\\infty,1,-\\infty,1]^T.</li> <li>f(u,x,p) is shown before.</li> <li>Prediction horizon T=3 s.</li> <li>Number of the discritization grids N=48.</li> <li>Discretization method: Euler.</li> </ul>"},{"location":"examples/exp_vehicle/#closed-loop-simulation-using-optimake","title":"Closed-loop Simulation using <code>OPTIMake</code>","text":"<p>Closed-loop simulation result:</p> <p> </p>"},{"location":"examples/exp_vehicle/#step-1-nmpc-problem-formulation","title":"Step 1. NMPC problem formulation","text":"<p>See Workflow of OPTIMake &gt; NMPC Problem Formulation.</p> <p>Example</p> <p><code>Vehicle/NMPC_Problem_Formulation.m</code></p>"},{"location":"examples/exp_vehicle/#step-2-code-generation-and-deployment-in-simulink","title":"Step 2. Code generation and deployment in Simulink","text":"<p>See Workflow of OPTIMake &gt; Code Generation and Deployment &gt; Simulink.</p> <ol> <li> <p>Code generation</p> <p>Example</p> <p><code>Vehicle/Simu_Simulink_Setup.m</code></p> </li> <li> <p>Deployment</p> <p>Example</p> <p><code>Vehicle/Simu_Simulink.slx</code></p> </li> </ol>"},{"location":"examples/workflow/","title":"Workflow of ParNMPC","text":""},{"location":"examples/workflow/#preparation","title":"Preparation","text":"<ol> <li>Choose a compiler that supports code generation with OpenMP by <code>mex -setup</code>.</li> <li>Edit <code>Timer.m</code> to specify your own timer function.</li> </ol>"},{"location":"examples/workflow/#nmpc-problem-formulation","title":"NMPC Problem Formulation","text":"<p>Example</p> <p><code>./NMPC_Problem_Definition.m</code></p> <ol> <li> <p>Formulate an OCP using Class <code>OptimalControlProblem</code> <pre><code>% Create an OptimalControlProblem object\nOCP = OptimalControlProblem(muDim,... % constraints dim\n                            uDim,...  % inputs dim\n                            xDim,...  % states dim\n                            pDim,...  % parameters dim (position reference)\n                            T,...     % prediction horizon\n                            N);       % num of discritization grids\n\n% Give names to x, u, p (optional)                          \n[~] = OCP.setStateName(~);\n[~] = OCP.setInputName(~);\n[~] = OCP.setParameterName(~);\n\n% Reset the prediction horizon T \n% (optional for variable horizon or nonuniform discretization)\nOCP.setT(~);\n\n% Set the dynamic function f\nOCP.setf(~);\n\n% Set the matrix M (optional for, e.g., Lagrange model)\nOCP.setM(~);\n\n% Set the equality constraint function C (optional)\nOCP.setC(~);\n\n% Set the cost function L\nOCP.setL(~);\n\n% Set the bound constraints (optional)\nOCP.setUpperBound('u',~);\nOCP.setLowerBound('u',~);\nOCP.setUpperBound('x',~);\nOCP.setLowerBound('x',~);\n\n% Set the polytopic constraint G (optional)\nOCP.setG(~);\nOCP.setUpperBound('G',~);\nOCP.setLowerBound('G',~);\n\n% Generate necessary files\nOCP.codeGen();\n</code></pre></p> </li> <li> <p>Configrate the solver using Class <code>NMPCSolver</code> <pre><code>% Create a NMPCSolver object\nnmpcSolver = NMPCSolver(OCP);\n\n% Configurate the Hessian approximation method\nnmpcSolver.setHessianApproximation(~);\n\n% Generate necessary files\nnmpcSolver.codeGen();\n</code></pre></p> </li> <li> <p>Solve the very first OCP for a given initial state and given parameters using Class <code>OCPSolver</code> <pre><code>% Set the initial state     \nx0 = [~];\n\n% Set the parameters        \npar = [~];\n\n% Create an OCPSolver object\nocpSolver = OCPSolver(OCP,nmpcSolver,x0,par);\n\n% Choose one of the following methods to provide an initial guess:\n% 1. init guess by input\nlambdaInitGuess = [~];\nmuInitGuess     = [~];\nuInitGuess      = [~];\nxInitGuess      = [~];\n% 2. init guess by interpolation\n[lambdaInitGuess,muInitGuess,uInitGuess,xInitGuess] = ...\n    ocpSolver.initFromStartEnd(~);\n% 3. init guess from file\n[lambdaInitGuess,muInitGuess,uInitGuess,xInitGuess] = ...\n                        ocpSolver.initFromMatFile(~);\n\n% Solve the OCP                     \n[lambda,mu,u,x] = ocpSolver.OCPSolve(lambdaInitGuess,...\n                                     muInitGuess,...\n                                     uInitGuess,...\n                                     xInitGuess,...\n                                     method...\n                                     maxIter);\n\n% Get the dependent variable LAMBDA\nLAMBDA = ocpSolver.getLAMBDA(x0,lambda,mu,u,x,par);\n\n% Check the cost % (optional)\ncost = ocpSolver.getCost(u,x,par); \n\n% Save to file for further use\nsave GEN_initData.mat  ...\n     x0 lambda mu u x par LAMBDA ~\n</code></pre></p> </li> <li> <p>Define the controlled plant using Class <code>DynamicSystem</code> (optional for simulation) <pre><code>% Create a DynamicSystem object\nplant = DynamicSystem(uDim,xDim,pDim);\n\n% Give names to x, u, p (optional)\n[~] = plant.setStateName(~);\n[~] = plant.setInputName(~);\n[~] = plant.setParameterName(~);\n\n% Set the dynamic function f\nplant.setf(~);\n\n% Set the matrix M (optional for, e.g., Lagrange model)\nplant.setM(~);\n\n% Generate necessary files\nplant.codeGen();\n</code></pre></p> </li> </ol> <p>Configuration Table:</p> Configurable discretization method Configurable Hessian approximation method <code>M</code> enabled <code>'Euler'</code> <code>'GaussNewton'</code> <code>M</code> disabled <code>'Euler'</code>, <code>'RK4'</code> <code>'Newton'</code>, <code>'GaussNewton'</code> when <code>'Euler'</code>;<code>'GaussNewton'</code> when <code>'RK4'</code>;"},{"location":"examples/workflow/#code-generation-and-deployment","title":"Code Generation and Deployment","text":""},{"location":"examples/workflow/#matlab","title":"MATLAB","text":"<p>Here, assume your closed-loop simulation is performed in <code>Simu_Matlab.m</code>.</p> <p>Example</p> <p><code>./Simu_Matlab.m</code></p>"},{"location":"examples/workflow/#code-generation","title":"Code generation","text":"<p>Example</p> <p><code>./Simu_Matlab_Codegen.m</code></p> <ol> <li> <p>Declare global variables as constants: <pre><code>global discretizationMethod isMEnabled ...\n       uMin uMax xMin xMax GMax GMin ...\n       veryBigNum\n\nglobalVariable = {'discretizationMethod',coder.Constant(discretizationMethod),...\n                  'isMEnabled',coder.Constant(isMEnabled),...\n                  'uMax',coder.Constant(uMax),...\n                  'uMin',coder.Constant(uMin),...\n                  'xMax',coder.Constant(xMax),...\n                  'xMin',coder.Constant(xMin),...\n                  'GMax',coder.Constant(GMax),...\n                  'GMin',coder.Constant(GMin),...\n                  'veryBigNum',coder.Constant(veryBigNum)};\n</code></pre></p> </li> <li> <p>Generate code using <code>codegen</code>: <pre><code>codegen -config:lib Simu_Matlab -globals globalVariable \n</code></pre> C code will be automatically generated to <code>./codegen/lib/Simu_Matlab</code>.</p> </li> </ol>"},{"location":"examples/workflow/#deployment-in-visual-studio","title":"Deployment in Visual Studio","text":"<ol> <li> <p>Create an empty Win32 Console Application project.</p> </li> <li> <p>Change to Release x64 mode.</p> </li> <li> <p>Add  <code>*.h</code> and <code>*.c</code> files in <code>.\\codegen\\lib\\Simu_Matlab</code> to the project.</p> </li> <li> <p>Add  <code>main.h</code> and <code>main.c</code> in <code>.\\codegen\\lib\\Simu_Matlab\\examples</code> to the project.</p> </li> <li> <p>Add directory <code>.\\codegen\\lib\\Simu_Matlab</code> to Properties &gt; C/C++ &gt; General &gt;  Additional Include Directories.</p> </li> <li> <p>Properties &gt; C/C++ &gt; Language &gt;  Open MP Support: Yes (/openmp).</p> </li> <li> <p>Compile and run.</p> </li> </ol>"},{"location":"examples/workflow/#simulink","title":"Simulink","text":"<p>Here, assume your closed-loop simulation is performed in Simulink. You can call the generated C/C++ solver function <code>NMPC_Iter</code> directly to compute the optimal input.</p>"},{"location":"examples/workflow/#code-generation_1","title":"Code generation","text":"<p>Example</p> <p><code>./Simu_Simulink_Setup.m</code></p> <ol> <li> <p>Define the degree of parallelism: <pre><code>DoP = ~; % degree of parallism: 1 = in serial, otherwise in parallel\n</code></pre></p> </li> <li> <p>Split \\{\\lambda_i\\}_{i=1}^{N}, \\{\\mu_i\\}_{i=1}^{N}, \\{u_i\\}_{i=1}^{N}, \\{x_i\\}_{i=1}^{N}, \\{p_i\\}_{i=1}^{N}, and \\{\\Lambda_i\\}_{i=1}^{N} along the prediction horizon into <code>DoP</code> pieces: <pre><code>sizeSeg     = N/DoP;\nlambdaSplit = reshape(lambda, lambdaDim,  sizeSeg,DoP);\nmuSplit     = reshape(mu,     muDim,      sizeSeg,DoP);\nuSplit      = reshape(u,      uDim,       sizeSeg,DoP);\nxSplit      = reshape(x,      xDim,       sizeSeg,DoP);\npSplit      = reshape(par,    pDim,       sizeSeg,DoP);\nLAMBDASplit = reshape(LAMBDA, xDim, xDim, sizeSeg,DoP);\n</code></pre></p> </li> <li> <p>Generate dll (lib or mex) and copy it to the working directory: <pre><code>args_NMPC_Iter = {x0,...\n                  lambdaSplit,...\n                  muSplit,...\n                  uSplit,...\n                  xSplit,...\n                  pSplit,...\n                  LAMBDASplit};\nNMPC_Iter_CodeGen('dll','C',args_NMPC_Iter);\ncopyfile('./codegen/dll/NMPC_Iter/NMPC_Iter.dll');\n</code></pre></p> </li> </ol>"},{"location":"examples/workflow/#deployment","title":"Deployment","text":"<p>Example</p> <p><code>./Simu_Simulink.slx</code></p> <p>Note</p> <p>This example shows how to call the generated C interface in Simulink using the <code>coder.cevel</code> function within a <code>MATLAB Function</code> block.  You can also call the C/C++ interface using S-function.</p> <ol> <li> <p>Open the Simulation Target pane in the Simulink Editor: Simulation &gt; Model Configuration Parameters &gt; Simulation Target.</p> </li> <li> <p>Add <code>#include \"NMPC_Iter.h\"</code> to Insert custom C code in generated: Header file.</p> </li> <li> <p>Add the following directory to Additional Build Information: Include directories: <pre><code>./codegen/dll/NMPC_Iter\n</code></pre></p> </li> <li> <p>Add <code>NMPC_Iter.lib</code> to Additional Build Information: Libraries.</p> </li> <li> <p>Call the generated C function in a <code>MATLAB Function</code> block in Simulink: <pre><code>coder.ceval('NMPC_Iter',...\n             x0,...\n             coder.ref(lambdaSplit),...\n             coder.ref(muSplit),... (optional)\n             coder.ref(uSplit),...\n             coder.ref(xSplit),...\n             coder.ref(pSplit),...  (optional)\n             coder.ref(LAMBDASplit),...\n             coder.wref(cost),...\n             coder.wref(error),...\n             coder.wref(timeElapsed));\n</code></pre></p> </li> </ol>"},{"location":"examples/workflow/#accelerating-simulation-using-mex-function","title":"Accelerating Simulation using MEX-function","text":"<ol> <li> <p>Code generation</p> <p>Example</p> <p><code>./Simu_Simulink_Setup.m</code></p> <p>Following the code generation for Simulink procedure, MEX-function can be generated by modifying the generation target to <code>mex</code>: <pre><code>NMPC_Iter_CodeGen('mex','C',args_NMPC_Iter);\n</code></pre></p> </li> <li> <p>Deployment</p> <p>Example</p> <p><code>./Simu_Matlab.m</code></p> <p>Modify <code>NMPC_Iter</code> to <code>NMPC_Iter_mex</code> to call the generated <code>mex</code> function: <pre><code>[lambdaSplit,muSplit,uSplit,xSplit,...\n LAMBDASplit,cost,error,timeElapsed] =\n NMPC_Iter_mex(x0,lambdaSplit,muSplit,...\n               uSplit,xSplit,pSplit,...\n               LAMBDASplit);\n</code></pre> and run.</p> <p>MEX-function is typically slower than C code. However, it can speed up your simulation to check the closed-loop response.</p> </li> </ol>"},{"location":"examples/workflow/#file-dependency","title":"File Dependency","text":"<p>Legend\uff1a</p> <p> </p>"},{"location":"examples/workflow/#advanced-functions","title":"Advanced Functions","text":"<ul> <li> <p>From the file dependency, you can even edit directly, e.g., <code>OCP_F_Fu_Fx</code>, to specify your own dynamic function F(u,x,p), and its Jacobians \\partial F/\\partial u and \\partial F/\\partial x rather than using the auto-generated <code>OCP_GEN_~.m</code>.</p> </li> <li> <p>Currently, only the 4-th order Runge-Kutta method is provided to simulate the controlled plant. You can also program your own method by calling <code>SIM_GEN_~.m</code>.</p> </li> </ul>"}]}